By default, MSMQ stores some messages in memory for increased performance, and a message may be sent and received from a queue without ever having been written to disk. This is not normally a problem, and it is completely transparent to you as the developer, but if the MSMQ service were to unexpectedly terminate due to a hardware or software failure, or due to some external circumstance such as a power failure, messages stored only in memory will be lost forever. You can control this behavior, forcing MSMQ to store a message to disk, by specifying that a message should be recoverable. A message can be marked as recoverable by setting the Recoverable property of a Message object before sending, or if you are not using Message objects and are just sending objects directly (described in Accessing Message Queues as the simple method of sending messages) you can control this behavior by setting the DefaultPropertiesToSend property on the MessageQueue object. In the code snippet to follow, a Message object is created, marked as recoverable, and then sent to the local private queue named "Orders."

Por padrão, o MSMQ armazena algumas mensagens na memória por motivos de performance, e as mensagens podem ser enviadas e recebidas de uma fila sem sequer necessitarem ser gravadas em Disco. Até aí não vemos problema algum, e isso é completamente transparente seja para o desenvolvedor, seja para o usuario. Mas, e se o serviço do MSMQ terminar de forma inesperada motivada por uma queda de tensão, queima do servidor ou desligamento inesperado? as mensagens, que ficam armazenadas somente na memória, se perderão e aí teremos o caos instalado e começarão os problemas.
Mas, existe uma saída para isso. Nas figuras 13 temos a mensagem presente na fila, mas ela está presente apenas na memória.

[Figura 13]

Porém, houve, como informado anteriormente,um problema técnico externo ao servidor que causou o seu desligamento e ao retornar o serviço ao ar, notamos que a mensagem sumiu, como nos mostra a Figura 14.

[Figura 14]

É um grande prejuízo. Mas, controlamos este comportamento forçando o MSMQ a armazenar a mensagem no disco e fazemos isso informando que a mesma é "recuperável". 
Uma mensagem pode ser marcada como recuperável setando a propriedade Recoverable no objeto Message antes de enviá-la mas, se não estamos utilizando o objeto Message para o envio e estamos utilizando o envio direto, veremos mais adiante, podemos controlar este comportamento setando a propriedade DefaultPropertiesToSend no objeto MessageQueue, que é o que acessa a Fila que veremos mais adiante como fazer.
Na Listagem 1, o objeto Message é criado, marcado como recuperável, e então enviado a nossa Fila de exemplo que contém o mesmo nome.

The next code snippet shows how to configure the default properties information of the MessageQueue so that all messages sent without using an actual Message object will be marked as Recoverable.

A Listagem 2 mostra como configurar as propriedades padrão do objeto de controle da Fila MessageQueue para que todas as mensagens enviadas de forma direta, sem uso do objeto Message, sejam marcadas como recuperáveis.

Although the MSMQ interface is available for creating, deleting, and exploring message queues, you can also work with queues through the System.Messaging namespace. Several static methods (meaning you can call them without creating an actual instance of the class) have been provided on the MessageQueue class that give you the ability to check if a queue exists (Exists), create a queue (Create), and delete a queue (Delete). Using these methods, your application can check for the existence of a queue, and create it automatically if it does not exist. The function, GetQ, listed next provides the exact functionality just described:

Embora a interface gráfica do MSMQ permita a criação, deleção e navegação entre as filas de mensagens, podemos trabalhar com estas filas através do namespace System.Messaging. Muitos métdos estáticos estão disponíveis na Classe MessageQueue o que nos dá a liberade para verificar se a fila existe (utilizando o método Booleando Exists), criar a fila (utilizando Create), e apagar a query (utilizando Delete). Usando estes métodos, sua aplicação pode verificar a existência da fila, criá-la dinamicamente caso não exista. A função CriaOuRetornaFila descrita na Listagem 1 nos mostra de forma completa como fazer.

This type of code can simplify deployment because it removes the need to create any queues ahead of time, but the relative expense of calling Exists means that you will achieve better performance if the queue is created by the install, and your program can just assume it exists. It is also worth noting that your receiving code would also have to check for the existence of the desired queue, since it may not exist until after at least one message has been placed into it.
Note   Creating and deleting queues requires certain security permissions, and by default can only be done by the creator/owner of the queue or by an administrator. If you do not have sufficient permissions an exception will be raised with an "Access Denied" message.

O código da Listagem 1 pode simplificar a implementação porque elimina a necessidade de se repetir o trabalho de criar filas mais adiante na aplicação, mas existe um custo relativo de ficar chamando Exists e que temos uma melhor performance quando criamos apenas uma fila manualmente. 

Apagando Filas
The remaining static method that you will find useful is Delete, which takes a path to a queue, just like its two companions, Create and Exists, and in this case uses that path to find a queue and remove it from the server. This is, of course, a rather drastic action because it will destroy any messages currently stored inside that queue that could result in the loss of important data. To ensure a queue is successfully deleted, place the call to Delete within an error-handling structure similar to the one shown here:

Um método estático no qual é bastante útil é Delete, que busca o caminho da fila e a remove do servidor. Ou seja, é uma ação drástica ao extermo pois destrói qualquer mensagem armazenada na fila e isso pode resultar em perda de dados importantes, por isso, antes de utilizar este método, verifique se realmente exste tal necessidade ou se já efetuou a recepção das mensagens necessárias.
A Listagem 2 mostra como eliminar uma Fila de mensagens.

Enviando mensagens simples
To send a message to a queue using the simple method requires only a few steps: First, obtain a reference to the appropriate message queue (using the queue's path, format name, or label), and then use the MessageQueue object's Send method, supplying the object you wish to send and (if desired) a label for your message. That's it. All the options that control how a message is sent will use their default values, so you don't have to do anything else. The code shown next leverages the GetQ procedure (described earlier in this article) and sends a simple string message to a local private queue:

Para enviar uma mensagem à uma fila de uma forma simples, precisamos apenas de alguns passos: primeiro, tenha o caminho da fila e então utilize o método Send do objeto MessageQueue passando o que precisamos enviar e, se necessário, criar uma label para sua mensagem. Todas as opções que controlam o envio da mensagem estarão com seus valores default, então não vamos nos preocupar em configurá-los agora. A Listagem 3, mostra um trecho que envia um texto para a fila.

To specify a label for your message, a second parameter can also be included in your call to the Send method:
Para inserir uma label em nossa mensagem,um segundo parâmetro deve ser incluído na chamada do método Sendna linha 10 da Listagem 3. Na Listagem 4, vamos o método modificado.

To view the contents of an individual message, right-click the message, click Properties, and then click the Body tab. In the case of a simple send, with all the options set to their default, whatever object you sent will have been serialized into XML, similar to the sample shown next (and in Figure 2):
Para visualizar o conteúdo de uma mensagem, dê um clique com o botão direito do mouse sobre a mensagem, clique em Propriedades e então clique na aba Corpo, no nosso caso, foi um envio bem simples, com todas as opções padrão, seja qualquer objeto que tenhamos enviado, ele sempre será serializado dentro de uma sintaxe XML, na Figura 14, vemos o conteúdo de uma mensagem, a mesma fica na parte chamado Corpo ou Body.

To specify a label for your message, a second parameter can also be included in your call to the Send method.

Once you have placed messages onto your queue, someone will likely wish to retrieve those messages, taking the data off the queue in the order in which it was added. To obtain a message from the queue, and then retrieve the data it contains, requires a few important steps:

Como enviamos mensagens para uma fila, a aplicação agora precisa receber/processar esta mensagem, uma boa prática, como pede o conceito de Fila, é processar as mensagens na ordem em que a mesma chega à Fila.	Para que possamos obter uma mensagem da fila e então processar os dados retornados por ela, precisamos de alguns passos simples. Na Listagem 10, temos estes passos.

Using a Specific Formatter
The process is the same regardless of the data type that you sent, as long as the XML formatter was used. If another formatter, such as the BinaryMessageFormatter, was used, you must set the message to use the correct formatter before you can retrieve the message body. The following code shows retrieval of an instance of the Order class using the binary formatter:

Usando Formatters específicos
O processo é o mesmo independente do tipo enviado, assim como o formatter do XML foi utilizado. Se outro formatter, como por exemplo BinaryMessageFormatter, for usado, precisamos configurar as mensagens para usar o formatter correto antes de extrair os dados da mensagem. Na Listagem 11, temos um exemplo.

Uma vantagem do MSMQ é o armazenamento de mensagens de forma assíncrona e isso já foi explicado em várias partes deste artigo, porém, em alguns momentos, não temos como processar as mensagens que são enviadas e as que são extraídas uma a uma, pode acontecer de o servidor receber muitas mensagens e não ter condições de enviá-las ao mesmo tempo, diante disso, a extração destas pode ser feita em massa.
Quando recebemos uma mensagem oriunda da Fila, ela envia sempre a primeira mensagem recebida e esta mensagem quando recebida e processada por nossa aplicação, ela é eliminada da fila, e a pergunta que é feita é: Como fazer uma extração em massa destas mensagens fazendo contagens e as recebendo? a resposta é: utilizando o método GetAllMessages() que é uma Lista de objetos Message. Também podemos introduzir uma busca de mensagens através do método ReceiveById, o motivo do uso deste método é que GetAllMessages não extrai as mensagens do servidor, apenas as coloca em uma Lista, só o método Receive()e suas sobrecargas - ReceiveById, ReceiveByCorrelationId -  é capaz de efetuar este procedimento. A idéia principal é iterar dentro da lista de mensagens e deste ponto fazer o processamento necessário com as mensagens já formatadas em nossos objetos. A Listagem 12, nos dá um exemplo muito útil.

Transactions
Transações

The concept of transactions is part of a variety of different computing technologies, but the general meaning is always the same: to execute a multiple-step process such that either all or none of the steps will complete. In reality, transactions are handled by rolling back any steps that have already occurred if the entire transaction is not completed successfully. Regardless of the technology used to implement transactions, they are described using several basic concepts:
The beginning and end of the transaction must be indicated, so that it is known which actions are contained within that transaction.
If the transaction completes successfully, it is committed, which causes all the actions to become permanent and the transaction to end.
If the transaction fails, for whatever reason, it is aborted and a rollback occurs, undoing any actions that have already been executed before the abort.
For more information on the concept of transactions, as they apply in a more general way to the world of computing, check out the Microsoft® SQL Server™ technical article, Microsoft SQL Server: An Overview of Transaction Processing Concepts and the MS DTC.
MSMQ supports transactions in two different ways: internally by allowing multiple messages to be sent or received as part of a transaction and externally by participating in Distributed Transaction Coordinator (DTC) transactions. The difference between the two types of transactions will be discussed later in this article, but to participate in either type of transaction, you must be using transactional message queues.

O conceito de transação é um assunto um tanto comum em TI, mas de uma forma geral é sempre a mesma: executar multiplos passos de um processo mesmo que todos ou nenhum destes passos esteja completo. Normalmente, transações são manipuladas desfazendo qualquer passo que já tenha ocorrido se toda a transação não estiver tiver sucesso. À despeito da tecnologia utilizada para implementá-las, transaççoes são descritas em termos muito simples e básicos.
O início é o fim da transação precisa ser informado, então após isso saber quais as ações que será executadas dentro da transação.
Se a transação é completada com sucesso, ela é comitada, o que faz com que todas as ações se tornem permanentes e finaliza a transação.
Se a transação falha, por qualquer razão, ela é abortada e a operação de Rollback ou desfazer ocorre, desfazendo qualquer ação que já tenha sido executada antes do erro.
O MSMQ permite transação em dois modos diferentes: modo interno, permitindo que multiplas mensagens sejam enviadas ou recebeidas como parte de uma transação ou modo externo participando das transações do Microsoft DTC (Coordenador de Transações Distribuídas). A diferença entre estes dois tipos de transações serão discutidos posteriormente no artigo, mas para que possamos usufruir dos benefícios destes tipos de transação, precisamos utilizar filas para mensagens transacionais.
Para criar filas transacionais, basta fazer como mostrado na Figura 18.
Lembrando que filas transacionais só permitem receber mensagens oriundas de transações, caso contrário, ou recebemos um erro de MessageQueueException ou a mensagem não chega no servidor, é descartada ao chegar. 

If you are creating a queue programmatically and you intend on using that queue in transactions, you must specify this when you call the MessageQueue.Create method. The code snippet to follow creates a new transactional queue by supplying an additional parameter to the Create method.
Também podemos criar filas via código, precisamos informar isso quando chamamos o método MessageQueue.Create. A Listagem 13 mostra a forma correta da criação da fila transacional

You can determine if a queue supports transactions after it has been created by viewing the queue properties through the MSMQ management interfaces, or by checking the Transactional property of the MessageQueue object programmatically. The next code snippet illustrates how to create a new instance of a MessageQueue object and check if it supports transactions.
he next code snippet illustrates how to create a new instance of a MessageQueue object and check if it supports transactions.

Podemos determinar se uma fila suporte transações após terem sido criadas olhando suas propriedades no MSMQ Explorer em nosso Console, ou verificando a propriedade Transaction do objeto MessageQueue. A Listagem 14 demonstra como criar uma nova instância de um objeto MessageQueue e verificar se o mesmo é transacional ou não, para cada bloco de verificação uma forma de tratamento distinta.

Attempting to use transactions with a non-transactional queue will fail and result in an exception of type MessageQueueException. The reverse, sending or receiving messages from a transactional queue without using transactions, will also fail. If you are using a transactional queue, and you are just sending a single message, you must use a special overload of the MessageQueue.Send method to indicate that each individual send or receive should be wrapped in its own single transaction. This is accomplished by passing the value MessageQueueTransactionType.Single as the second parameter to the Send method.

A tentativa de usar transações com uma fila não transacional resultará em erro retornando uma exceção do tipo MessageQueueException como já foi informado anteriormente. Do contrário, enviando ou recebendo mensagens de uma fila transacional sem usar transacções, também irá falhar. Se usar uma fila transacional e apenas enviarmos uma mensagem apenas, precisamos usar uma sobrecarga especial do método do objeto MessageQueue.Send para indicar que cada envio individual ou recepção precisa estar encapsulada nesta sua única transação, isso é feito passando o enum MessageQueueTransactionType.Single como o segundo parâmetro para o método Send.

MSMQ provides built-in support for transactions, allowing you to execute multiple actions against one or more queues (sending or receiving messages) all wrapped in a transaction so that you can guarantee that either all or none of the actions will take effect. The transaction support provided within MSMQ is limited to MSMQ actions, however, and you will often be accessing other resources, such as a database, that you also wish to include in the same transaction. To allow for this, MSMQ also supports external transactions, where the Microsoft Distributed Transaction Coordinator (MS DTC), used by COM+ and SQL Server, is used to allow a variety of resources including databases and MSMQ to be included in a single transaction.

Sending and receiving within a transaction
To perform any MSMQ action(s) within an internal transaction, you need to create a MessageQueueTransaction object, begin the transaction, and then supply that object along with each of the actions you wish to include in the transaction.

MSMQ disponibiliza suporte nativo para transações, nos permitindo executar multiplas ações sobre uma ou mais filas (enviando ou recebendo mensagens) todos encapsulados em uma transação para que garanta que todas ou nenhuma das ações surtam efeito. O suporte para transação disponível dentro do MSMQ é limitado à ações do MSMQ, mas, podemos precisar acessar outros recursos, tais como Bancos de Dados, que desejamos incluir na mesma transação. Para permitir este acesso, MSMQ também permite o acesso à transações externas, onde o Coordenador de Transações Distribuídas da Microsoft (MS DTC), usado por COM+ e SQL Server, também pode ser utilizado para acessar grande parte de recursos incluindo Banco de Dados e MSMQ pode incluir em uma transação única.
Neste ponto, vamos começar a mostar a sintaxe para o uso de transações.

To perform any MSMQ action(s) within an internal transaction, you need to create a MessageQueueTransaction object, begin the transaction, and then supply that object along with each of the actions you wish to include in the transaction.
Para executar qualquer ação ou ações dentro de uma transação interna, precisamos instanciar o objeto MessageQueueTransaction, iniciar a transação e então utlizar este objeto durante a execução de cada ação que precisar utilizar uma transação. Na Listagem 15, temos um trecho que demonstra este modelo.

Once you have this MessageQueueTransaction object, the Send and Receive methods of the MessageQueue object both have an overloaded version that can accept a transaction object along with the other required information. As noted earlier, before you can send any messages as part of this new transaction, you must explicitly mark the beginning of the transaction by using the MessageQueueTransaction.Begin method. More details on controlling the transaction are provided in the next section, but note that your actions (send and receive) won't permanently affect the queue unless you commit the transaction, so a call to the MessageQueueTransaction.Commit method is required after the send or else the receive may not find any messages to retrieve. The two pieces of code to follow show how to both send and receive messages within a transaction.

Uma vez que tenhamos o objeto MessageQueueTransaction instanciado, os métodos Send e Receive do objeto MessageQueue ambos tem uma versão com sobrecarga que pode ser utilizado aceitar com objetos de transação. Como dito antes, antes que possamos enviar qualquer mensagem como parte desta nova transação, precisamos explicitamente marcar o início utilizando o método MessageQueueTransaction.Begin. 

The MessageQueueTransaction object itself supplies a variety of methods and properties that you can use to control the transaction and to examine its current status. In addition to the Begin method, which starts a transaction, the two methods that allow you to control how this transaction ends are Commit and Abort, which you can use to mark the transaction as having completed successfully or as having failed and needing to be rolled back. The simplest way to use the MessageQueueTransaction object to ensure that your transaction executes correctly is to wrap your MSMQ code in an error-handling block and to execute Abort if any error occurs and Commit if everything executes successfully. The following code gives an example of this method of transaction handling, sending two messages to a queue as part of transaction and wrapped in a try/catch/finally block. The transaction is aborted in the catch block, committed at the very end of the try block, and all of the objects are disposed of correctly in the finally block, ensuring that this housekeeping step will always occur.

O objeto MessageQueueTransaction por si só nos disponibiliza uma variedade de métodos e propriedades que podemos utilizar para controlar as transações e examinar seu estado. Junto com o método Begin, que começa a transação, os outros dois métodos que nos permitem controlar como esta transação termina são Commit e Abort, dos quais podemos utilizar para marcar as transações como tendo sucesso ou caso tenha falha e precise de Rollback. O caminho mais simples para se usar o objeto MessageQueueTransaction é permitir que sua transação execute corretamente dentro de um bloco para controle de erros e executar Abort caso algum erro ocorra e Commit se tudo correr bem. A Listagem 17 nos dá um exemplo desta abordagem para tratamento de transações, enviando duas mensagens para uma fila como parte de uma transação dentro de um bloco try/catch/finally. A transação é abortada no catch e commitada no final do bloco e todos os objetos são descartados no finally, permitindo que este tipo de limpeza sempre irá acontecer, seja no sucesso ou na falha.

In addition to the two control methods, the MessageQueueTransaction object also provides access to the current status of the transaction through the Status property, which will return one of four possible values:
- Initialized. The transaction object has been created, but no actions have occurred yet, so the transaction itself has not been started.
- Pending. Actions have occurred, but the transaction is still in progress—it has not committed or aborted.
- Committed. The transaction has completed successfully.
- Aborted. The transaction was aborted, and has been rolled back.
The Status property is an enumeration representing the four possible values. The code to follow shows how you could use it in your program.

Junto com estes dois métodos de controle, o objeto MessageQueueTransaction também disponibiliza o etado atual da transação através da propriedade Status que tem como tipo o Enum MessageQueueTransactionStatus que contém os valores informados em seguida:

- Initialized. The transaction object has been created, but no actions have occurred yet, so the transaction itself has not been started.

- Pending. Actions have occurred, but the transaction is still in progress—it has not committed or aborted.

- Committed. The transaction has completed successfully.
- Aborted. The transaction was aborted, and has been rolled back.


Initialized (Iniciada). A transação já foi criada, mas nenhuma ação ocorreu ainda, então a própria transação ainda não foi iniciada.
Pending (Pendente). Já ocorrerm algumas ações, mas a transação ainda está em progresso, logo não foi nem commitada ou abortada.
Commited (Commitada, sem tradução livre). A transação foi completada com sucesso.
Aborted (Abortada ou Cancelada). A transação foi abortada e efetuado o Rollback.

There are many different reasons to use transactions when you are working with MSMQ, but here is a specific example to assist you in understanding this technology. Consider a situation where orders are being sent into your back-end system via MSMQ. Your system retrieves messages off of a queue, processes the message, and then sends it on to another queue. At the same time you fire another message off into a log queue that you use to audit the movement of orders within your system. Without transactions, you could retrieve the order (removing it from the incoming queue) but never send it on to another queue due to some serious error. At this point, you have lost the order completely, and that is certainly not acceptable in most systems. A slightly less serious problem is that you could retrieve and process the order successfully but an error prevents you from sending an audit message to your log queue, leaving you with a log that incorrectly states that this order is still waiting to be processed. Either problem can be avoided by wrapping the entire activity, including the read from the incoming queue, the write to the outgoing queue, and the write to the audit queue in a transaction.

Existem muitas situações e diferentes razões para usarmos as transações quando utilizamos o MSMQ, mas há um exemplo específico que podemos aproveitar para fazer um melhor entendimento desta tecnologia. Imagine que Pedidos estão sendo enviados e tratados de dentro de nosso Sistema integrado com o MSMQ. Nosso sistema puxa mensagens da fila, processa a mensagem e então a envia para uma outra fila, a isto damos o nome de Roteamento. Ao mesmo tempo em que enviamos uma outra mensagem para uma fila de Log que podemos utilizar para auditar o movimento dos pedidos dentro do Sistema. Sem transações, poderíamos puxar o pedido (removendo-o completamente da fila) mas nunca poderíamos enviá-lo para outra fila, pois isso geraria erro. Neste ponto, perderíamos completamente o pedido, e isso não pode ser permitido em nosso Sistema. O que daria menos problema é tratar as ações de puxar e processar o pedido e quando estas ações ocorrem com sucesso é que podemos enviar novas mensagens de auditoria para a nossa fila de Log, evitando assim a leitura de um Log que foi gravado incorretamente pois o pedido poderia estar sendo processado ou nem ter sido puxado ainda. Outro problema que pode ser evitado protegendo em bloco de controle toda a atividade, incluindo tanto o envio, a recepção e processamento de mensagens e o envio posterior para a fila de auditoria, tudo isso dentro de uma transação. Com transações, temos segurança e confiabilidade, justamente os dois pilares do conceito de Filas de Mensagens.

MSMQ transactions are very useful, but they are limited to dealing with MSMQ activities only, while most systems that use MSMQ will also be using other resources, such as a database. Using only MSMQ transactions, you could end up with a database that is out of sync with the state of your message queues. Consider the real-world example just discussed, where an order is read off of a queue and then sent to a new queue, followed by a log entry being sent to another queue for auditing purposes. It is not unlikely that a database could be involved in a scenario like that, perhaps as the destination for the order or serving as the location to log audit information. If an error were to occur and MSMQ transactions were in use, the MSMQ activities would be rolled back, but the database work would not. Such a situation is little better than using no transaction processing at all, because the result could still be unreliable data in your system. The solution is to use a form of transaction processing that is capable of handling the database and MSMQ work as part of a single transaction, and that technology is called MS DTC, or Microsoft Distributed Transaction Coordinator. Using DTC allows you to initiate a transaction and then proceed to use resources from multiple sources, such as an SQL Server database and MSMQ, and then have those resources participate in that transaction, committing or rolling back as appropriate when the transaction ends.

As transações do MSMQ são muito úteis, mas são limitadas apenas ao domínio de atividades do MSMQ, enquanto muitos sistema que utilizam o MSMQ também utilizam outros recursos, tais como bancos de dados, como já foi dito anteriormente. Usando apenas transações do MSMQ, não teremos sincronia com um Banco de Dados. Voltando ao exemplo anterior do Sistema de Pedidos, onde um pedido é lido de uma fila e então enviado à outra fila, seguido por uma entrada em um Log, que também é uma mensagem enviada a uma outra fila para auditoria. Poderíamos colocar um Banco de Dados dentro deste cenário recebendo as entradas para o Log de Auditoria recebendo desta fila em específico. Se um erro ocorrer e uma transação do MSMQ estiver em curso, as atividades do MSMQ não desfeitas, mas não o trabaho do banco de dados e aí teríamos o mesmo problema o que faz com que muitos desistam desta integração, mas há sempre uma saída para sanar este modelo. A solução é usar uma forma de processar a transação capaz de manipular o Banco de Dados e o trabalho do MSMQ como parte de uma única transação e esta tecnologia se chama Coordenador de Transações Distribuídas da Microsoft, ou MS DTC. Usar o DTC permite que iniciemos uma transação e então podemos utilizar recursos de muitos sistemas, tais como o SQL Sever e o MSMQ, e então ter estes recursos participando da mesma transação, commitando e desfazendo dependendo do fim da transação.

Note   DTC only supports resources that have implemented compatible interfaces that manage the transaction for that specific resource. These interfaces are referred to as "Resource Managers" (see the .NET Framework Developer's Guide documentation on Distributed Transactions for more information on this topic) and are provided by several resources at this time, including MSMQ, Microsoft SQL Server, Oracle, Sybase, and others.

Creating a serviced component and setting transaction attributes

To use DTC transactions from your .NET system, you need to take advantage of the services provided by MTS/COM+ by running your code within their environment. Before .NET, this was accomplished by creating a COM component and registering that component as part of a COM+ application (known as a package in MTS) and setting the properties of that application so that COM+ would run it as part of a transaction. Once your component was placed into COM+, and set up to require a transaction, any access from that component to a DTC-compatible resource became part of the same transaction and could be committed or rolled back as a group. In .NET, you accomplish the same results by building a class that inherits from the System.EnterpriseServices.ServicedComponent class and then setting this class up with attributes indicating that it requires a transaction. Creating a class like this enables it to run inside COM+. The process to create, register, and use serviced components is covered in detail in the .NET Framework Developer's Guide documentation titled "Writing Serviced Components." The code to follow shows a sample class configured to run within COM+, with assembly attributes that set up the COM+ application properties and a class attribute <Transaction(TransactionOption.Required)> that indicates a transaction is required when this class is used.

Criando um componente e configurando para uso em transações

Para utilizarmos as transações do DTC de dentro do .NET, precisamos saber as vantagens dos serviços disponibilizados por uso de COM+ dentro de nosso ambiente. Antes do .NET, isso era feito criando componentes COM e os registrando como parye de uma aplicação COM+ e configurando propriedades desta aplicação para que o compnente COM+ pudesse funcionar como parte de uma transação. Uma vez registrado, e configurada a transação, qualquer acesso deste componente para um recurso compatível com o DTC se tornava parte desta mesma transação e poderia ser commitada ou desfeita via Rollback. Dentro do .NET, atingimos os mesmos objetivos construindo uma Classe que herde a Classe System.EnterpriseServices.ServicedComponent e então decore seu namespace com attributes indicando que precisa de uma transação. Criando uma Classe como essa, temos possibilidade de executá-la dentro do COM+. Informações adicionais sobre como criar, registrar e disponibilizar componentes podem ser encontradas na seção Links deste artigo, porém, criaremos um componente e o registraremos de forma bem básica como ilustração de como o MSMQ com o DTC é bastante produtivo. A Listagem 17, mostra um trecho de código de Classe decorada com os attributes necessários para ser registrada como componente. No Visual Studio é só criar uma Classe simples e fazer como na Listagem.

Using the System.EnterpriseServices.ContextUtil class, the code within your COM+ component can control the transaction in a very similar manner to the internal MSMQ code shown earlier in this article. ContextUtil provides a variety of methods, including SetAbort and SetComplete, which roll back and commit the transaction respectively.

Usando a Classe System.EnterpriseServices.ContextUtil, o código dentro de seu componente COM+ pode controlar a transação de uma maneira muito similar ao tratamento interno do MSMQ que fizemos anteriormente neste artigo. ContextUtil disponbiliza uma variedade de métodos, incluindo setAbort e SetComplete, que desfaz com Rollback ou commita a transação respectivamente.

Alternatively, instead of explicitly using the ContextUtil object to control your transaction, you can also use an attribute to tell COM+ that it should automatically commit or abort the transaction based on what happens inside your code. By placing the attribute <AutoComplete()> on your procedure, the transaction will be automatically committed—as is the case with ContextUtil.SetComplete()—if the procedure ends without raising any exceptions, and automatically aborted—as is the case with ContextUtil.SetAbort()—if an exception is raised and not handled within the procedure itself. To make this work correctly, you will need to either remove the error-handling block from your code or raise another exception from the catch block to ensure that the transaction is automatically aborted. I recommend the latter method, as it is better to explicitly catch exceptions in your code then to just remove all error handling.

Existe uma outra forma de controlar a transação utilizando o objeto ContextUtil, podemos usar um attribute para informar ao COM+ que ele pode automaticamente efetuar o commit e o Rollback da transação, basta que decoremos o método com <AutoComplete()>, então a transação será automaticamente commitada - como se utilizasse ContextUtil.SetAbort() - e se uma exceção for lançada ela não será manipulada pelo método. Para que isso funcione corretamente, precisamos retirar o bloco de manipulação de erros or colocar outro tratamento de exceção para permitir que a transação seja automaticamente abortada.

In the end, when you have built your component and installed it into COM+, clients can create and call your component just like any other .NET class, and your component will automatically run inside COM+ and act as part of a transaction.
Então, quando construímos nosso componente e o instalamos dentro da COM+, clientes podem fazer chamadas em nosso componente como se chamasse qualquer outra classe .NET e nosso componente pode rodar automaticamente dentro da COM+ e agir como parte de uma transação.

When you perform an action synchronously, like calling a method on an object, you receive immediate feedback on the success of that action, but with asynchronous processes, a mechanism needs to be provided that will give you the same level of feedback. For this purpose, MSMQ provides acknowledgements, special MSMQ-generated messages that are sent to inform the sending application that a message was successfully delivered to and/or retrieved at the destination. In the examples included in this article, and in the examples from the earlier asynchronous article, messages are sent to a private queue that is located on the local machine, so successful delivery doesn't require an acknowledgement message. But this isn't always the case. In many situations, MSMQ is used in an offline (disconnected) mode, where messages are destined for some remote server but must be stored locally and then forwarded on to that remote server (or another server along the way) when a connection is available. In such a situation, the message has not been delivered when the call to MessageQueue.Send completes, so an acknowledgement of delivery becomes useful.

Quando efetuamos uma ação síncrona, como chamar um método dentro de um objeto, você recebe uma resposta imediata do sucesso desta ação, mas com processos assíncronos é preciso criar algum mecanismo que tenha o mesmo comportamento. Para este propósito, o MSMQ disponibiliza os acknowledgements ou recibos que são mensagens especiais geradas pelo MSMQ que são enviadas para informar a aplicação cliente que a mensagem foi entregue para e/ou baixada no destino. Nas Listagens anteriores que vimos, mensagens são enviadas para uma fila particular que está localizada na máquina local, então entregas com sucesso não precisam de mensagens acknowledgement. Mas, isso não vem ao caso. Em muitas situações, MSMQ é usado em modo offline, onde as mensagens que são destinadas ao servidor remoto mas precisam ser armazenadas localmente e então enviadas a este servidor, ou a outro da rede, quando a conexão fica disponível novamente. Com isso, a mensagem não foi entregue ainda quando a chamada ao método MessageQueue.Send se completa, para esse tipo de arquitetura, um recibo de entrega se torna muito útil.

Setting up acknowledgements requires the creation of a queue to receive these special messages, which can be any non-transactional queue, and setting certain properties on your messages before you send them. The code shown next creates the new queue and then sends a message after setting the two required properties—AdministrationQueue, which is used to indicate where the acknowledgement messages are sent, and AcknowledgeTypes, which indicates what particular events should cause a message to be sent.

Configurar acknowledgements requer a criação de uma fila para receber estas mensagens especias, que pode ser qualquer fila não transacional, e configurar certas propriedades em sua mensagem antes de enviá-las. A Listagem 20 cria uma nova fila e então envia uma mensagen após configurar as duas propriedades necessárias - AdministrationQueue, que é utilizada para indicar onde as mensagens de recibo serão enviadas, e AcknowledgeTypes, que é um Enum que indica quais eventos fazem com que a mensagem de recibo seja enviada.

The available settings for AcknowledgeTypes are:
FullReachQueue (success and failure to be delivered to the queue)
FullReceive (success and failure to be received)
NegativeReceive (failure to be received)
NotAcknowledgeReachQueue (failure to be delivered)
NotAcknowledgeReceive (failure to be received)
PositiveArrival (successful delivery)
PositiveReceive (successful receive)

This property is a mask bit, allowing you to combine multiple types of acknowledgment to produce the results you desire. You could, for instance, specify PositiveArrival Or PositiveReceive to indicate that you want all success acknowledgements. The preceding code snippet specified FullReachQueue Or FullReceive to indicate that all positive and negative results should be acknowledged. As with almost any Message property, you can also set these properties through the DefaultPropertiesToSend property of the MessageQueue object, allowing you to use the simple method of sending messages and still use the acknowledgement features.

Os valores disponíveis para AcknowledgeTypes são:
FullReachQueue. Sucesso e falha ao ser entregue na fila.
FullReceive. Sucesso e falha ao receber da fila.
NegativeReceive. Falha ao ser recebida da fila.
NotAcknowledgeReachQueue. Falha na entrega.
NotAcknowledgeReceive. Falha ao receber da fila.
PositiveArrival. entrega com sucesso.
PositiveReceive. recepção da fila com sucesso.

Com este Enum, podemos combinar multiplos tipos de recibos para atender à nossa necessidade quanto à natureza das mensagens. Podemos, por exemplo, especificar PositiveArrival ou PositiveReceive para indicar que queremos todos os recibos de sucesso. Na Listagem 21, utilizamos FullReachQueue ou FullReceive para informar que todos os resultados positivos e negativos enviarão recibos. Também podemos configurar estes valores na propriedade DefaultPropertiesToSend do objeto MessageQueue, nos permitindo utilizar apenas um método de envio de mensagens e ainda aproveitar as vantagens do uso de recibos.

or acknowledgements to be of much use, your application has to do more than just request them—it also needs to receive them. Acknowledgement messages are a little different than regular MSMQ messages; they consist only of header information with no body, but receiving them works in the same manner as a regular message. Because there is no body, it is the other properties of the Message object that are important when you are receiving an acknowledgement message, but not every property is automatically received by the MessageQueue.Receive() method. There is another property of the MessageQueue object: MessageReadPropertyFilter, which is used to control exactly which message properties are received. If you look at the documentation in the .NET Framework Class Library for the MessagePropertyFilter class, you will find a list of which properties are retrieved by default, but the best bet is to explicitly tell the queue to receive the properties you need. The code snippet to follow does just that, informing the queue that the CorrelationID property should be received.

Para que as mensagens de confirmação sejam úteis realmente, nossa aplicação precisa fazer algo mais do que apenas solicitá-los, também precisamos recebê-los. Mensagens recibo são mensagens um pouco diferente das tradicionais do MSMQ; elas consistem apenas em ter informações no cabeçalho, não têm corpo, mas o processo de nossa aplicação recebê-las funciona da mesma maneira que uma mensagem regular. Como as mensagens não tem corpo, existem outras propriedades que são importantes quando nossa aplicação recebe uma mensagem de confirmação. mas nem toda propriedade é automaticamente configurada no método MessageQueue.Receive(). Existe outra propriedade no objeto MessageQueue, que é MessageReadPropertyFilter, que é utilizado para controlar exatamente quais propriedades da mensagem serão recebidas pelo objeto. A lista de MessageReadPropertyFilter não será disponibilizada neste artigo por questão de abordagem, mas é facilmente encontrado na internet. Uma melhor prática é informar a fila quais propriedades precisamos receber, a Listagem 22 faz justamente isso, informa a queue que a propriedade CorrelationID precisa ser recebida pela aplicação.

