Rabiscos sobre o Artigo sobre segurança no ASP.NET MVC

[Depois de criar todas as Camadas de Entidade, Generico, DAL e Persistência]

- TDD 
O Desenvolvimento orientado a testes é uma realidade quando se trata de projetos ágeis, com o TDD temos grandes vantagens, mas a maior delas é justamente a economia de tempo, posto que programamos todos os módulos do Sistema, depois que criarmos seus testes e estes testes forem sempre positivos. Muitos não notam, mas as novas IDEs como o Visual Studio para o .NET, o Eclipse e o NetBeans para o Java, dentre outras IDEs já utilizam TDD, posto que basta que o programador erre algum comado ou alguma sintaxe para vermos quela linhazinha vermelha embaixo do erro e parando o mouse em cima, podemos ver o que fizemos de errado e logo em seguida corrigimos o erro e a marca vermelha some, este também é um tipo de teste, e é chamado de Teste Estático, um Teste Estático também é executado quando compilamos alguma aplicação, aqui no .NET por exemplo, no nosso Visual Studio, quando compilamos algo que nos retorna um erro, é porque o teste estático falhou, resumindo: o Teste Estático é quando o nosso código é testado. E as IDEs que identificam o erro em tempo de desenvolvimento e não em tempo de execução atendem a um termo chamado Fail Fast, ou seja, Falha Rápida que significa que "precisamos ter o erro logo no início do desenvolvimento, para que não tenhamos surpresas no momento da execução do software", qualquer framework, trecho de código ou executável que nos mostre erros logo após um comando ou simplesmente após uma digitação nos faz economizar muito código e principalmente, muito tempo. Todo Sistema sério e robusto que se preze precisa de um Sistema de Resposta a falhas ou seja, que reporte uma falha imediatamente: isso é programação Fail Fast, isso é programação extrema, isso é XP. Muitos falam das vantagens e desvantagens do uso do TDD, e a maioria argumenta que perde muito tempo programando para encontrar erros, afinal de contas o TDD é realmente para isso: testar a maturidade do código e principalmente evitar problemas quando o Projeto está bastante adiantado, problemas podem ocorrer tais como: um componente que não funciona corretamente, um trecho de código que foi feito por uma pessoa que não faz mais parte da equipe e tal trecho não compila ou não funciona corretamente em tempo de execução. Em nosso artigo vamos utilizar o TDD e com ele alguns tipos de testes, lembrando que falar sobre testes não é o intuito deste nosso artigo,portanto sitarei alguns tipos de testes que serão utilizados aqui a fim de didática:

- Teste Estático: Teste efetuado para testar o código, podemos fazer uma análise estática do código simplesmente o observando ou permitindo que a nossa IDE o faça, como já foi dito anteriormente. Este é o teste primário.

- Teste de Integração: Neste teste, verificamos como os módulos do Sistema quando interconectados vão funcionar corretamente, no nosso artigo, utilizamos o Linq to SQL com classes decoradas, UnitOfWork que acessa a Classe de Conexão para se conectar a base de dados, e todos são Módulos desacoplados, este teste visa verificar se há algum problema nesta junção e nos informar

- Teste de Regressão: Neste Teste, serve para verificar se a cada novo módulo inserido no Sistema, este módulo não influencia nos outros já existentes, um exemplo disso é que inicialmente criamos um teste e o executamos, diante disso, vamos continuar a programar e criamos um segundo teste para verificar outra parte do Sistema e esta parte tambem passa no teste, para verificar se tudo correu bem, executamos agora os dois testes, se o resultado for positivo, o novo artefato inserido no sistema não conflitou com os que já existiam, esta é a vantagem deste teste.

Um ponto importante a ser levantado neste ponto é que o TDD é criado para realmente se encontrar falhas, posto que sem falhas encontradas, o Sistema tende a ser bem mais maduro. No que tange aos erros encontrados, nós podemos marcá-los como bons ou ruins, isso pode parecer muito estranho posto que como que um erro será bom? bem, esta qualidade está na forma de se encontrar o erro, um exemplo que ilustra este ponto de vista, foi durante a escrita deste artigo. Nos deparamos com uma situação em que o DataContext não conectava a base de forma alguma e decidimos verificar o motivo, no teste de integração, o Sistema não encontrava a String de Conexão, diante disto fizemos uma criação manual da connectionString e reexecutamos o Teste de Integração, bem, a String de Conexão chegou até o Banco de Dados e fez a conexão, porém, relatou um erro nos mapeamentos do Linq to SQL. Diante disso, corrigimos um erro e caímos em outro totalmente diferente, este tipo de erro foi considerado bom ou ruim? a resposta que virá em nossa mente será sempre ruim, afinal de contas, um erro é sempre um erro, mas neste ponto de vista, nos deparamos com um erro e o corrigimos, então caímos em outro mais à frente, isso significa que evoluímos no processo, certo? pois bem, isto faz este erro que encontramos ser bom, agora, se ficamos presos em um único erro por muito tempo e não conseguimos sair dele, então este erro é ruim e está atrapalhando o processo de desenvolvimento seja deste desenvolvedor e portanto será um problema para a equipe também, diante disso,ligue o Andon e peça auxílio. Outra forma de um erro ser ruim ou nocivo é quando após um módulo funcional novo passar nos testes, o Teste de Regressão acuse uma falha motivada por este novo módulo que possa ter causado algum bug na integração, neste ponto, é um erro ruim posto que causou um certo prejuízo ao Sistema e terá que ser corrigido, sem o TDD, tais erros só seriam vistos após a entrega deste módulo, ou se estiver usando cascata, apenas na entrega e execução do software por parte do cliente. Creio que não precisamos informar mais nada a respeito das vantagens e desvantagens do TDD. Apenas informamos que os problemas encontrados podem ser rapidamente resolvidos sem sequer causar transtornos a todo o Projeto e facilita também a documentação da aplicação.

Criando nosso Pacote de Testes

Como toda a forma explicada anteriormente neste artigo, vamos criar um componente para efetuar nossos testes na Arquitetura de nossa Aplicação. Inicialmente, vamos criar um projeto apenas para testar as entidades, o CRUD, a conexão com o Banco e tudo o mais abaixo da Camada de Apresentação, posto que nela, criaremos outro pacote de testes, por se tratar de um framework como o ASP.NET MVC, teremos uma outra forma de testar a aplicação, por isso, é uma boa prática separar os testes de forma que o Sistema fique facilmente compreensível para os que estão no Projeto e para as equipes de manutenção caso existam, ou outros desenvolvedores que possam participar do Projeto.

Na nossa Solution, crie um Class Library com o nome MVCSeguranca.Ed109.Testes e dentro dele crie as Pastas como na Figura XXX

[Inserir a Figura XXX - Estrutura do Pacote MVCSeguranca.Ed109.Testes]

Testes com NUnit

Para nossos testes unitários, vamos utilizar o NUnit, tal framework de testes unitários é gratuito e uma outra solução para Testes Unitários além do Microsoft Test Toolkit que vem junto com o Visual Studio, ambos são bem parecidos, porém, o NUnit tem a vantagem de testar o projeto do Visual Studio fora do mesmo, e também permite um debug utilizando breakpoints do Visual Studio sem problemas, tal debug veremos mais adiante. O NUnit quando instalado, detem uma interface GUI totalmente desacoplada do Visual Studio,o que nos dá mais liberdade para fazer nossos testes em um ambiente livres de vicios de ambiente e framework e também mostra ao desenvolvedor se seus assemblies referenciados estão funcionando corretamente.

Configurando o NUnit para nossos testes.

O NUnit é bem simples de ser manuseado, inicialmente crie um atalho na sua área de trabalho apontando para o seu executável onde ele foi baixado e extraído, caso tenha sido instalado, ele já estará lá. Vamos criar o nosso Projeto inicial. Temos aqui uma pequena convenção: vamos criar o Projeto do NUnit dentro de nosso Projeto MVCSeguranca.Ed109.Testes

Alguns Attributes do NUnit úteis